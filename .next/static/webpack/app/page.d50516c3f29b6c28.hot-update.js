"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction useSupabaseData(user) {\n    // Caches for songs and liked songs to avoid repeated cloud fetches\n    const songsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const likedSongsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Personalized songs state (smart sorted, filtered, and history-excluded)\n    const [personalizedSongs, setPersonalizedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Trending songs state (top 15 by views+likes)\n    const [trendingSongs, setTrendingSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [recentlyPlayedSongs, setRecentlyPlayedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Get user ID from localStorage or session\n    const getUserId = ()=>{\n        try {\n            // First try to get from session user\n            if (user === null || user === void 0 ? void 0 : user.id) {\n                console.log(\"\\uD83C\\uDD94 Using session user ID:\", user.id);\n                return user.id;\n            }\n            // Fallback to localStorage\n            const userData = localStorage.getItem(\"musicapp_user\");\n            if (userData) {\n                const parsed = JSON.parse(userData);\n                console.log(\"\\uD83C\\uDD94 Using localStorage user ID:\", parsed.id);\n                return parsed.id;\n            }\n            console.log(\"❌ No user ID available\");\n            return null;\n        } catch (error) {\n            console.error(\"❌ Error getting user ID:\", error);\n            return null;\n        }\n    };\n    // Get personalized songs based on user's actual listening preferences\n    const getSmartPersonalizedSongs = async (userId, listenedSongsInBatch, excludeSongs)=>{\n        try {\n            var _listenedSongsInBatch_;\n            console.log(\"\\uD83E\\uDDE0 Fetching smart personalized songs based on listening behavior\");\n            console.log(\"\\uD83C\\uDFB5 Songs user actually listened to:\", listenedSongsInBatch.map((s)=>s.name));\n            if (listenedSongsInBatch.length === 0) {\n                console.log(\"⚠️ No listened songs in batch, falling back to regular personalization\");\n                return [];\n            }\n            // Extract tags and artists from listened songs\n            const preferredTags = new Set();\n            const preferredArtists = new Set();\n            listenedSongsInBatch.forEach((song)=>{\n                var _song_tags;\n                (_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.forEach((tag)=>preferredTags.add(tag.toLowerCase()));\n                preferredArtists.add(song.artist.toLowerCase());\n            });\n            console.log(\"\\uD83C\\uDFF7️ Preferred tags:\", Array.from(preferredTags));\n            console.log(\"\\uD83C\\uDFA4 Preferred artists:\", Array.from(preferredArtists));\n            // Use cache if available, otherwise fetch and cache\n            let songsData = songsCache.current;\n            if (!songsData) {\n                console.log(\"\\uD83D\\uDCE5 Fetching songs from database for smart recommendations...\");\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for smart personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n                console.log(\"✅ Songs cached for smart recommendations:\", data.length);\n            }\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                console.log(\"\\uD83D\\uDCE5 Fetching liked songs for smart recommendations...\");\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n                console.log(\"✅ Liked songs cached:\", userLikedSongs.size);\n            }\n            // Filter and score songs based on listening preferences and language\n            // Use the language of the first listened song as the filter\n            const languageFilter = (_listenedSongsInBatch_ = listenedSongsInBatch[0]) === null || _listenedSongsInBatch_ === void 0 ? void 0 : _listenedSongsInBatch_.language;\n            const availableSongs = songsData.filter((song)=>{\n                return !excludeSongs.has(song.file_id.toString()) && song.language === languageFilter;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs for smart recommendations (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // Score songs based on user's listening preferences\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // High priority: Tag matching with listened songs\n                const songTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.map((tag)=>tag.toLowerCase())) || [];\n                const matchingTags = songTags.filter((tag)=>preferredTags.has(tag));\n                score += matchingTags.length * 25; // Higher weight for tag matching\n                // High priority: Artist matching with listened songs\n                if (preferredArtists.has(song.artist.toLowerCase())) {\n                    score += 30; // Higher weight for artist matching\n                }\n                // Medium priority: Same language as listened songs\n                const listenedLanguages = listenedSongsInBatch.map((s)=>s.language);\n                if (listenedLanguages.includes(song.language)) {\n                    score += 15;\n                }\n                // Lower priority: General popularity\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Bonus for liked songs\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 10;\n                }\n                // Add small randomness to avoid repetition\n                score += Math.random() * 2;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 15) // Get more songs for variety\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83E\\uDDE0 Smart recommendations based on listening behavior:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getSmartPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for fetching songs\");\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDCE5 Fetching all songs from supabase for user:\", userId);\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) {\n                console.error(\"❌ Error fetching songs:\", error);\n                throw error;\n            }\n            console.log(\"✅ Fetched songs:\", songsData === null || songsData === void 0 ? void 0 : songsData.length);\n            // Fetch liked songs\n            console.log(\"\\uD83D\\uDCE5 Fetching liked songs for user:\", userId);\n            let userLikedSongs = new Set();\n            const { data: likedData, error: likedError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            if (likedError) {\n                console.error(\"❌ Error fetching liked songs:\", likedError);\n            } else if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n                console.log(\"✅ Fetched liked songs:\", userLikedSongs.size);\n            }\n            // Fetch user history (for minutes_listened)\n            console.log(\"\\uD83D\\uDCE5 Fetching user history for user:\", userId);\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened, songs(*)\").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            });\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            } else {\n                console.log(\"✅ Fetched user history:\", historyData === null || historyData === void 0 ? void 0 : historyData.length);\n            }\n            // Get top 15 most listened songs from history\n            const topHistory = (historyData || []).slice(0, 15).filter((h)=>h.songs);\n            // Collect tags and artists from top 15\n            const tagCount = {};\n            const artistCount = {};\n            topHistory.forEach((h)=>{\n                // h.songs may be an array or object, use first if array\n                const songObj = Array.isArray(h.songs) ? h.songs[0] : h.songs;\n                ((songObj === null || songObj === void 0 ? void 0 : songObj.tags) || []).forEach((tag)=>{\n                    const t = tag.toLowerCase();\n                    tagCount[t] = (tagCount[t] || 0) + 1;\n                });\n                if (songObj === null || songObj === void 0 ? void 0 : songObj.artist) {\n                    const a = songObj.artist.toLowerCase();\n                    artistCount[a] = (artistCount[a] || 0) + 1;\n                }\n            });\n            // Find most common tags and artists\n            const commonTags = Object.entries(tagCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [tag] = param;\n                return tag;\n            });\n            const commonArtists = Object.entries(artistCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [artist] = param;\n                return artist;\n            });\n            console.log(\"\\uD83C\\uDFF7️ Found similar tags:\", commonTags);\n            console.log(\"\\uD83C\\uDFA4 Found similar artists:\", commonArtists);\n            // Songs in history (to exclude for smart sort)\n            const historySongIds = new Set((historyData || []).map((h)=>{\n                var _h_song_id;\n                return (_h_song_id = h.song_id) === null || _h_song_id === void 0 ? void 0 : _h_song_id.toString();\n            }));\n            // Convert all songs\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            setSongs(convertedSongs); // songs is now all songs, not personalized\n            console.log(\"✅ Set all songs:\", convertedSongs.length);\n            // Filter out songs in history for personalized sort\n            const filteredSongs = convertedSongs.filter((song)=>!historySongIds.has(song.id));\n            // Score songs by tag/artist match\n            const scoredSongs = filteredSongs.map((song)=>{\n                let score = 0;\n                // Tag match\n                const songTags = (song.tags || []).map((t)=>t.toLowerCase());\n                score += songTags.filter((t)=>commonTags.includes(t)).length * 10;\n                // Artist match\n                if (song.artist && commonArtists.includes(song.artist.toLowerCase())) {\n                    score += 20;\n                }\n                // Popularity\n                score += (song.views || 0) + (song.likes || 0);\n                return {\n                    song,\n                    score\n                };\n            });\n            // Sort by score descending\n            const personalizedSorted = scoredSongs.sort((a, b)=>b.score - a.score).map((s)=>s.song);\n            setPersonalizedSongs(personalizedSorted);\n            console.log(\"✅ Set personalized songs:\", personalizedSorted.length);\n            // Trending: top 15 by views+likes (from all songs, including history)\n            const trending = [\n                ...convertedSongs\n            ].sort((a, b)=>b.views + b.likes - (a.views + a.likes)).slice(0, 15);\n            setTrendingSongs(trending);\n            console.log(\"✅ Set trending songs:\", trending.length);\n            console.log(\"\\uD83D\\uDD25 Trending songs:\", trending.slice(0, 5).map((s)=>\"\".concat(s.name, \" (\").concat(s.views, \" views, \").concat(s.likes, \" likes)\")));\n            // Set last played song\n            console.log(\"\\uD83D\\uDCE5 Fetching last played song for user:\", userId);\n            const { data: userData, error: userError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", userId).single();\n            if (userError) {\n                console.error(\"❌ Error fetching user data:\", userError);\n            } else if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                    console.log(\"✅ Set last played song:\", lastSong.name);\n                }\n            }\n        } catch (error) {\n            console.error(\"❌ Error fetching songs:\", error);\n            setSongs([]);\n            setPersonalizedSongs([]);\n            setTrendingSongs([]);\n        }\n    };\n    // Get personalized songs with proper error handling and filtering\n    const getPersonalizedSongs = async (userId, currentSong, listenedSongs)=>{\n        try {\n            console.log(\"\\uD83C\\uDFB5 Fetching personalized songs for:\", currentSong.name);\n            console.log(\"\\uD83C\\uDFB5 Listened songs count:\", (listenedSongs === null || listenedSongs === void 0 ? void 0 : listenedSongs.size) || 0);\n            // 1. Fetch all songs from cache or cloud\n            let songsData = songsCache.current;\n            if (!songsData) {\n                console.log(\"\\uD83D\\uDCE5 Cache miss, fetching songs from database...\");\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n                console.log(\"✅ Songs cached:\", data.length);\n            }\n            // 2. Fetch user's listening history (not cached, as it may change frequently)\n            console.log(\"\\uD83D\\uDCE5 Fetching listening history for personalization...\");\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened\").eq(\"user_id\", userId);\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            }\n            const historyMap = new Map();\n            if (historyData) {\n                historyData.forEach((h)=>historyMap.set(h.song_id, h.minutes_listened || 0));\n                console.log(\"✅ History loaded:\", historyData.length, \"entries\");\n            }\n            // 3. Get user's liked songs from cache or cloud\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                console.log(\"\\uD83D\\uDCE5 Cache miss, fetching liked songs...\");\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n                console.log(\"✅ Liked songs cached:\", userLikedSongs.size);\n            }\n            // 4. Filter and score songs (add language filter)\n            const languageFilter = currentSong.language;\n            const availableSongs = songsData.filter((song)=>{\n                // Exclude current song\n                if (song.file_id === currentSong.file_id) {\n                    return false;\n                }\n                // Exclude listened songs if provided\n                if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                    console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                    return false;\n                }\n                // Only include songs with the same language as current song\n                if (song.language !== languageFilter) {\n                    return false;\n                }\n                return true;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs after filtering (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // 5. Score and sort songs\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // Tag matching (highest priority)\n                const matchingTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.filter((tag)=>{\n                    var _currentSong_tags;\n                    return (_currentSong_tags = currentSong.tags) === null || _currentSong_tags === void 0 ? void 0 : _currentSong_tags.includes(tag);\n                })) || [];\n                score += matchingTags.length * 15;\n                // Artist matching\n                if (song.artist === currentSong.artist) {\n                    score += 25;\n                }\n                // Language matching\n                if (song.language === currentSong.language) {\n                    score += 10;\n                }\n                // Listening history boost\n                const listenedMinutes = historyMap.get(song.file_id) || 0;\n                score += Math.min(listenedMinutes * 2, 20); // Cap at 20 points\n                // Popularity boost (likes and views)\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Liked songs boost\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 8;\n                }\n                // Add controlled randomness to avoid repetition\n                score += Math.random() * 3;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // 6. Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 10) // Get more songs to have a buffer\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83C\\uDFB5 Personalized recommendations:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            console.log(\"\\uD83C\\uDFB5 Total available songs:\", availableSongs.length);\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Fetch recently played songs based on listening history\n    const fetchRecentlyPlayed = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for fetching recently played\");\n            setRecentlyPlayedSongs([]);\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDCE5 Fetching recently played songs for user:\", userId);\n            // Get user's listening history sorted by minutes listened\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"\\n          song_id,\\n          minutes_listened,\\n          songs (*)\\n        \").eq(\"user_id\", userId).order(\"minutes_listened\", {\n                ascending: false\n            }).limit(9);\n            if (historyError) {\n                console.error(\"❌ Error fetching recently played:\", historyError);\n                return;\n            }\n            if (!historyData || historyData.length === 0) {\n                console.log(\"\\uD83D\\uDCED No recently played songs found\");\n                setRecentlyPlayedSongs([]);\n                return;\n            }\n            // Get user's liked songs for proper conversion\n            console.log(\"\\uD83D\\uDCE5 Fetching liked songs for recently played conversion...\");\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // Convert to Song format\n            const recentSongs = historyData.filter((item)=>item.songs) // Ensure song data exists\n            .map((item)=>{\n                const songObj = Array.isArray(item.songs) ? item.songs[0] : item.songs;\n                return convertDatabaseSong(songObj, userLikedSongs.has(item.song_id));\n            });\n            setRecentlyPlayedSongs(recentSongs);\n            console.log(\"✅ Set recently played songs:\", recentSongs.length);\n        } catch (error) {\n            console.error(\"❌ Error fetching recently played songs:\", error);\n            setRecentlyPlayedSongs([]);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for fetching playlists\");\n            setPlaylists([]);\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDCE5 Fetching playlists for user:\", userId);\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", userId);\n            if (error) {\n                console.error(\"❌ Error fetching playlists:\", error);\n                throw error;\n            }\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n            console.log(\"✅ Set playlists:\", convertedPlaylists.length);\n        } catch (error) {\n            console.error(\"❌ Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for toggling like\");\n            return;\n        }\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            console.log(\"\".concat(isCurrentlyLiked ? \"\\uD83D\\uDC94\" : \"❤️\", \" Toggling like for song:\"), songId, \"User:\", userId);\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", userId).eq(\"song_id\", songFileId);\n                if (error) {\n                    console.error(\"❌ Error removing like:\", error);\n                    throw error;\n                }\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n                console.log(\"✅ Song unliked successfully\");\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").insert({\n                    user_id: userId,\n                    song_id: songFileId\n                });\n                if (error) {\n                    console.error(\"❌ Error adding like:\", error);\n                    throw error;\n                }\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n                console.log(\"✅ Song liked successfully\");\n            }\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"❌ Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for creating playlist\");\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDCDD Creating playlist:\", name, \"for user:\", userId);\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").insert({\n                user_id: userId,\n                name\n            }).select().single();\n            if (error) {\n                console.error(\"❌ Error creating playlist:\", error);\n                throw error;\n            }\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n            console.log(\"✅ Playlist created successfully:\", newPlaylist.name);\n        } catch (error) {\n            console.error(\"❌ Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for deleting playlist\");\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDDD1️ Deleting playlist:\", playlistId, \"for user:\", userId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) {\n                console.error(\"❌ Error deleting playlist:\", error);\n                throw error;\n            }\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n            console.log(\"✅ Playlist deleted successfully\");\n        } catch (error) {\n            console.error(\"❌ Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for renaming playlist\");\n            return;\n        }\n        try {\n            console.log(\"✏️ Renaming playlist:\", playlistId, \"to:\", newName, \"for user:\", userId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", userId);\n            if (error) {\n                console.error(\"❌ Error renaming playlist:\", error);\n                throw error;\n            }\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n            console.log(\"✅ Playlist renamed successfully\");\n        } catch (error) {\n            console.error(\"❌ Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for adding song to playlist\");\n            return;\n        }\n        try {\n            console.log(\"➕ Adding song:\", song.name, \"to playlist:\", playlistId, \"for user:\", userId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) {\n                console.error(\"❌ Error adding song to playlist:\", error);\n                throw error;\n            }\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n            console.log(\"✅ Song added to playlist successfully\");\n        } catch (error) {\n            console.error(\"❌ Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for removing song from playlist\");\n            return;\n        }\n        try {\n            console.log(\"➖ Removing song:\", songId, \"from playlist:\", playlistId, \"for user:\", userId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) {\n                console.error(\"❌ Error removing song from playlist:\", error);\n                throw error;\n            }\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n            console.log(\"✅ Song removed from playlist successfully\");\n        } catch (error) {\n            console.error(\"❌ Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for updating last song\");\n            return;\n        }\n        try {\n            console.log(\"\\uD83D\\uDCDD Updating last song:\", songId, \"for user:\", userId);\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", userId);\n            if (error) {\n                console.error(\"❌ Error updating last song:\", error);\n                throw error;\n            }\n            console.log(\"✅ Last song updated successfully\");\n        } catch (error) {\n            console.error(\"❌ Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        const userId = getUserId();\n        if (!userId) {\n            console.log(\"❌ No user ID available for recording listening history\");\n            return;\n        }\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    console.log(\"\\uD83D\\uDCCA Recording listening time:\", minutes, \"minutes for song:\", currentSongRef.current);\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"❌ Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        console.log(\"\\uD83C\\uDFB5 Started tracking song:\", songId);\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            console.log(\"\\uD83D\\uDC41️ Incrementing views for song:\", songId);\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n            console.log(\"✅ Views incremented successfully\");\n        } catch (error) {\n            console.error(\"❌ Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        const userId = getUserId();\n        if (currentSongRef.current && currentSongStartTime && userId) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    console.log(\"\\uD83D\\uDED1 Recording final listening time:\", minutes, \"minutes for song:\", currentSongRef.current);\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: userId,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"❌ Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n        console.log(\"\\uD83D\\uDED1 Stopped song tracking\");\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            const userId = getUserId();\n            if (!userId) {\n                console.log(\"❌ No user ID available, resetting data\");\n                // Reset data when no user\n                songsCache.current = null;\n                likedSongsCache.current = null;\n                setSongs([]);\n                setPersonalizedSongs([]);\n                setTrendingSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setRecentlyPlayedSongs([]);\n                setLastPlayedSong(null);\n                setLoading(false);\n                return;\n            }\n            try {\n                console.log(\"\\uD83D\\uDD04 Loading data for user:\", userId);\n                setLoading(true);\n                await Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists(),\n                    fetchRecentlyPlayed()\n                ]);\n                console.log(\"✅ All data loaded successfully\");\n            } catch (error) {\n                console.error(\"❌ Error loading data:\", error);\n                // Reset data on error\n                setSongs([]);\n                setPersonalizedSongs([]);\n                setTrendingSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setRecentlyPlayedSongs([]);\n                setLastPlayedSong(null);\n            } finally{\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        user\n    ]) // Keep dependency on user to trigger when auth state changes\n    ;\n    return {\n        songs,\n        personalizedSongs,\n        trendingSongs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        recentlyPlayedSongs,\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            console.log(\"\\uD83D\\uDD04 Refreshing all data...\");\n            fetchSongs();\n            fetchPlaylists();\n            fetchRecentlyPlayed();\n        },\n        getPersonalizedSongs,\n        getSmartPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBR0o7QUFFN0MsU0FBU0ksZ0JBQWdCQyxJQUFpQjtJQUMvQyxtRUFBbUU7SUFDbkUsTUFBTUMsYUFBYUosNkNBQU1BLENBQWU7SUFDeEMsTUFBTUssa0JBQWtCTCw2Q0FBTUEsQ0FBcUI7SUFDbkQsTUFBTSxDQUFDTSxPQUFPQyxTQUFTLEdBQUdOLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBQ08sbUJBQW1CQyxxQkFBcUIsR0FBR1IsK0NBQVFBLENBQVMsRUFBRTtJQUNyRSwrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDUyxlQUFlQyxpQkFBaUIsR0FBR1YsK0NBQVFBLENBQVMsRUFBRTtJQUM3RCxNQUFNLENBQUNXLFdBQVdDLGFBQWEsR0FBR1osK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNhLFlBQVlDLGNBQWMsR0FBR2QsK0NBQVFBLENBQWMsSUFBSWU7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHakIsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDa0IscUJBQXFCQyx1QkFBdUIsR0FBR25CLCtDQUFRQSxDQUFTLEVBQUU7SUFDekUsTUFBTSxDQUFDb0IsU0FBU0MsV0FBVyxHQUFHckIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDc0Isc0JBQXNCQyx3QkFBd0IsR0FBR3ZCLCtDQUFRQSxDQUFjO0lBQzlFLE1BQU13QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBZ0I7SUFFN0MsMkNBQTJDO0lBQzNDLE1BQU0wQixZQUFZO1FBQ2hCLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsSUFBSXZCLGlCQUFBQSwyQkFBQUEsS0FBTXdCLEVBQUUsRUFBRTtnQkFDWkMsUUFBUUMsR0FBRyxDQUFDLHVDQUE2QjFCLEtBQUt3QixFQUFFO2dCQUNoRCxPQUFPeEIsS0FBS3dCLEVBQUU7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LHVDQUE2QlM7Z0JBQ3pDaEIsV0FBVztnQkFDWCxNQUFNK0osUUFBUUMsR0FBRyxDQUFDO29CQUFDdkY7b0JBQWN3QztvQkFBa0JIO2lCQUFzQjtnQkFDekV4RyxRQUFRQyxHQUFHLENBQUM7WUFDZCxFQUFFLE9BQU9PLE9BQU87Z0JBQ2RSLFFBQVFRLEtBQUssQ0FBQyx5QkFBeUJBO2dCQUN2QyxzQkFBc0I7Z0JBQ3RCN0IsU0FBUyxFQUFFO2dCQUNYRSxxQkFBcUIsRUFBRTtnQkFDdkJFLGlCQUFpQixFQUFFO2dCQUNuQkUsYUFBYSxFQUFFO2dCQUNmRSxjQUFjLElBQUlDO2dCQUNsQkksdUJBQXVCLEVBQUU7Z0JBQ3pCRixrQkFBa0I7WUFDcEIsU0FBVTtnQkFDUkksV0FBVztZQUNiO1FBQ0Y7UUFFQThKO0lBQ0YsR0FBRztRQUFDakw7S0FBSyxFQUFFLDZEQUE2RDs7SUFFeEUsT0FBTztRQUNMRztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRSxZQUFZUixNQUFNZ0UsTUFBTSxDQUFDdEIsQ0FBQUEsT0FBUUEsS0FBSzRDLE9BQU87UUFDN0N6RTtRQUNBRjtRQUNBSTtRQUNBMEg7UUFDQWM7UUFDQUU7UUFDQUU7UUFDQUc7UUFDQUs7UUFDQUU7UUFDQVE7UUFDQUksYUFBYTtZQUNYM0osUUFBUUMsR0FBRyxDQUFDO1lBQ1prRTtZQUNBd0M7WUFDQUg7UUFDRjtRQUNBVjtRQUNBckY7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cz9hYmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFiYXNlU29uZywgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSc7XG5pbXBvcnQgeyBQbGF5bGlzdCwgU29uZyB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdXBhYmFzZURhdGEodXNlcjogVXNlciB8IG51bGwpIHtcbiAgLy8gQ2FjaGVzIGZvciBzb25ncyBhbmQgbGlrZWQgc29uZ3MgdG8gYXZvaWQgcmVwZWF0ZWQgY2xvdWQgZmV0Y2hlc1xuICBjb25zdCBzb25nc0NhY2hlID0gdXNlUmVmPGFueVtdIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxpa2VkU29uZ3NDYWNoZSA9IHVzZVJlZjxTZXQ8bnVtYmVyPiB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc29uZ3MsIHNldFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIC8vIFBlcnNvbmFsaXplZCBzb25ncyBzdGF0ZSAoc21hcnQgc29ydGVkLCBmaWx0ZXJlZCwgYW5kIGhpc3RvcnktZXhjbHVkZWQpXG4gIGNvbnN0IFtwZXJzb25hbGl6ZWRTb25ncywgc2V0UGVyc29uYWxpemVkU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgLy8gVHJlbmRpbmcgc29uZ3Mgc3RhdGUgKHRvcCAxNSBieSB2aWV3cytsaWtlcylcbiAgY29uc3QgW3RyZW5kaW5nU29uZ3MsIHNldFRyZW5kaW5nU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW3BsYXlsaXN0cywgc2V0UGxheWxpc3RzXSA9IHVzZVN0YXRlPFBsYXlsaXN0W10+KFtdKVxuICBjb25zdCBbbGlrZWRTb25ncywgc2V0TGlrZWRTb25nc10gPSB1c2VTdGF0ZTxTZXQ8bnVtYmVyPj4obmV3IFNldCgpKVxuICBjb25zdCBbbGFzdFBsYXllZFNvbmcsIHNldExhc3RQbGF5ZWRTb25nXSA9IHVzZVN0YXRlPFNvbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbcmVjZW50bHlQbGF5ZWRTb25ncywgc2V0UmVjZW50bHlQbGF5ZWRTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKVxuICBjb25zdCBbY3VycmVudFNvbmdTdGFydFRpbWUsIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKVxuICBjb25zdCBjdXJyZW50U29uZ1JlZiA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPihudWxsKVxuXG4gIC8vIEdldCB1c2VyIElEIGZyb20gbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25cbiAgY29uc3QgZ2V0VXNlcklkID0gKCk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGaXJzdCB0cnkgdG8gZ2V0IGZyb20gc2Vzc2lvbiB1c2VyXG4gICAgICBpZiAodXNlcj8uaWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhpQgVXNpbmcgc2Vzc2lvbiB1c2VyIElEOicsIHVzZXIuaWQpXG4gICAgICAgIHJldHVybiB1c2VyLmlkXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgY29uc3QgdXNlckRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbXVzaWNhcHBfdXNlcicpXG4gICAgICBpZiAodXNlckRhdGEpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh1c2VyRGF0YSlcbiAgICAgICAgY29uc29sZS5sb2coJ/CfhpQgVXNpbmcgbG9jYWxTdG9yYWdlIHVzZXIgSUQ6JywgcGFyc2VkLmlkKVxuICAgICAgICByZXR1cm4gcGFyc2VkLmlkXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gdXNlciBJRCBhdmFpbGFibGUnKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGdldHRpbmcgdXNlciBJRDonLCBlcnJvcilcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgYWN0dWFsIGxpc3RlbmluZyBwcmVmZXJlbmNlc1xuICBjb25zdCBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGxpc3RlbmVkU29uZ3NJbkJhdGNoOiBTb25nW10sIFxuICAgIGV4Y2x1ZGVTb25nczogU2V0PHN0cmluZz5cbiAgKTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp6AgRmV0Y2hpbmcgc21hcnQgcGVyc29uYWxpemVkIHNvbmdzIGJhc2VkIG9uIGxpc3RlbmluZyBiZWhhdmlvcicpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgU29uZ3MgdXNlciBhY3R1YWxseSBsaXN0ZW5lZCB0bzonLCBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5tYXAocyA9PiBzLm5hbWUpKTtcbiAgICAgIFxuICAgICAgaWYgKGxpc3RlbmVkU29uZ3NJbkJhdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIGxpc3RlbmVkIHNvbmdzIGluIGJhdGNoLCBmYWxsaW5nIGJhY2sgdG8gcmVndWxhciBwZXJzb25hbGl6YXRpb24nKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IHRhZ3MgYW5kIGFydGlzdHMgZnJvbSBsaXN0ZW5lZCBzb25nc1xuICAgICAgY29uc3QgcHJlZmVycmVkVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgY29uc3QgcHJlZmVycmVkQXJ0aXN0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgXG4gICAgICBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5mb3JFYWNoKHNvbmcgPT4ge1xuICAgICAgICBzb25nLnRhZ3M/LmZvckVhY2godGFnID0+IHByZWZlcnJlZFRhZ3MuYWRkKHRhZy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIHByZWZlcnJlZEFydGlzdHMuYWRkKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn4+377iPIFByZWZlcnJlZCB0YWdzOicsIEFycmF5LmZyb20ocHJlZmVycmVkVGFncykpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjqQgUHJlZmVycmVkIGFydGlzdHM6JywgQXJyYXkuZnJvbShwcmVmZXJyZWRBcnRpc3RzKSk7XG5cbiAgICAgIC8vIFVzZSBjYWNoZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmZXRjaCBhbmQgY2FjaGVcbiAgICAgIGxldCBzb25nc0RhdGEgPSBzb25nc0NhY2hlLmN1cnJlbnQ7XG4gICAgICBpZiAoIXNvbmdzRGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TpSBGZXRjaGluZyBzb25ncyBmcm9tIGRhdGFiYXNlIGZvciBzbWFydCByZWNvbW1lbmRhdGlvbnMuLi4nKVxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3MgZm9yIHNtYXJ0IHBlcnNvbmFsaXphdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHNvbmdzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHNvbmdzRGF0YSA9IGRhdGE7XG4gICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IGRhdGE7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU29uZ3MgY2FjaGVkIGZvciBzbWFydCByZWNvbW1lbmRhdGlvbnM6JywgZGF0YS5sZW5ndGgpXG4gICAgICB9XG5cbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCF1c2VyTGlrZWRTb25ncykge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TpSBGZXRjaGluZyBsaWtlZCBzb25ncyBmb3Igc21hcnQgcmVjb21tZW5kYXRpb25zLi4uJylcbiAgICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpO1xuICAgICAgICB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgICAgICBpZiAobGlrZWREYXRhKSB7XG4gICAgICAgICAgbGlrZWREYXRhLmZvckVhY2goaXRlbSA9PiB1c2VyTGlrZWRTb25ncyEuYWRkKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50ID0gdXNlckxpa2VkU29uZ3M7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTGlrZWQgc29uZ3MgY2FjaGVkOicsIHVzZXJMaWtlZFNvbmdzLnNpemUpXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbHRlciBhbmQgc2NvcmUgc29uZ3MgYmFzZWQgb24gbGlzdGVuaW5nIHByZWZlcmVuY2VzIGFuZCBsYW5ndWFnZVxuICAgICAgLy8gVXNlIHRoZSBsYW5ndWFnZSBvZiB0aGUgZmlyc3QgbGlzdGVuZWQgc29uZyBhcyB0aGUgZmlsdGVyXG4gICAgICBjb25zdCBsYW5ndWFnZUZpbHRlciA9IGxpc3RlbmVkU29uZ3NJbkJhdGNoWzBdPy5sYW5ndWFnZTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNvbmdzID0gc29uZ3NEYXRhLmZpbHRlcigoc29uZykgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICFleGNsdWRlU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSAmJlxuICAgICAgICAgIHNvbmcubGFuZ3VhZ2UgPT09IGxhbmd1YWdlRmlsdGVyXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfjrUgQXZhaWxhYmxlIHNvbmdzIGZvciBzbWFydCByZWNvbW1lbmRhdGlvbnMgKGxhbmd1YWdlOiAke2xhbmd1YWdlRmlsdGVyfSk6ICR7YXZhaWxhYmxlU29uZ3MubGVuZ3RofWApO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBTY29yZSBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgbGlzdGVuaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBzY29yZWRTb25ncyA9IGF2YWlsYWJsZVNvbmdzLm1hcCgoc29uZykgPT4ge1xuICAgICAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IFRhZyBtYXRjaGluZyB3aXRoIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGNvbnN0IHNvbmdUYWdzID0gc29uZy50YWdzPy5tYXAoKHRhZzogc3RyaW5nKSA9PiB0YWcudG9Mb3dlckNhc2UoKSkgfHwgW107XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IHNvbmdUYWdzLmZpbHRlcigodGFnOiBzdHJpbmcpID0+IHByZWZlcnJlZFRhZ3MuaGFzKHRhZykpO1xuICAgICAgICBzY29yZSArPSBtYXRjaGluZ1RhZ3MubGVuZ3RoICogMjU7IC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHRhZyBtYXRjaGluZ1xuXG4gICAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IEFydGlzdCBtYXRjaGluZyB3aXRoIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGlmIChwcmVmZXJyZWRBcnRpc3RzLmhhcyhzb25nLmFydGlzdC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIHNjb3JlICs9IDMwOyAvLyBIaWdoZXIgd2VpZ2h0IGZvciBhcnRpc3QgbWF0Y2hpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lZGl1bSBwcmlvcml0eTogU2FtZSBsYW5ndWFnZSBhcyBsaXN0ZW5lZCBzb25nc1xuICAgICAgICBjb25zdCBsaXN0ZW5lZExhbmd1YWdlcyA9IGxpc3RlbmVkU29uZ3NJbkJhdGNoLm1hcChzID0+IHMubGFuZ3VhZ2UpO1xuICAgICAgICBpZiAobGlzdGVuZWRMYW5ndWFnZXMuaW5jbHVkZXMoc29uZy5sYW5ndWFnZSkpIHtcbiAgICAgICAgICBzY29yZSArPSAxNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvd2VyIHByaW9yaXR5OiBHZW5lcmFsIHBvcHVsYXJpdHlcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLmxpa2VzIHx8IDApKSAqIDI7XG4gICAgICAgIHNjb3JlICs9IE1hdGgubG9nKDEgKyAoc29uZy52aWV3cyB8fCAwKSkgKiAxO1xuXG4gICAgICAgIC8vIEJvbnVzIGZvciBsaWtlZCBzb25nc1xuICAgICAgICBpZiAodXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpIHtcbiAgICAgICAgICBzY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBzbWFsbCByYW5kb21uZXNzIHRvIGF2b2lkIHJlcGV0aXRpb25cbiAgICAgICAgc2NvcmUgKz0gTWF0aC5yYW5kb20oKSAqIDI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb25nOiBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmcsIHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSwgXG4gICAgICAgICAgc2NvcmVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGFuZCByZXR1cm4gdG9wIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gc2NvcmVkU29uZ3NcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMTUpIC8vIEdldCBtb3JlIHNvbmdzIGZvciB2YXJpZXR5XG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIFNtYXJ0IHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBsaXN0ZW5pbmcgYmVoYXZpb3I6JywgXG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5zbGljZSgwLCA1KS5tYXAocyA9PiBgJHtzLm5hbWV9IGJ5ICR7cy5hcnRpc3R9YCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29udmVydCBkYXRhYmFzZSBzb25nIHRvIFVJIHNvbmcgZm9ybWF0XG4gIGNvbnN0IGNvbnZlcnREYXRhYmFzZVNvbmcgPSAoZGJTb25nOiBEYXRhYmFzZVNvbmcsIGlzTGlrZWQ6IGJvb2xlYW4gPSBmYWxzZSk6IFNvbmcgPT4gKHtcbiAgICBmaWxlX2lkOiBkYlNvbmcuZmlsZV9pZCxcbiAgICBpbWdfaWQ6IGRiU29uZy5pbWdfaWQsXG4gICAgbmFtZTogZGJTb25nLm5hbWUsXG4gICAgYXJ0aXN0OiBkYlNvbmcuYXJ0aXN0LFxuICAgIGxhbmd1YWdlOiBkYlNvbmcubGFuZ3VhZ2UsXG4gICAgdGFnczogZGJTb25nLnRhZ3MsXG4gICAgdmlld3M6IGRiU29uZy52aWV3cyxcbiAgICBsaWtlczogZGJTb25nLmxpa2VzLFxuICAgIGlkOiBkYlNvbmcuZmlsZV9pZC50b1N0cmluZygpLFxuICAgIGltYWdlOiBgaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvJHtkYlNvbmcuaW1nX2lkfS9wZXhlbHMtcGhvdG8tJHtkYlNvbmcuaW1nX2lkfS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDBgLFxuICAgIGlzTGlrZWRcbiAgfSlcblxuICAvLyBGZXRjaCBhbGwgc29uZ3NcbiAgY29uc3QgZmV0Y2hTb25ncyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlIGZvciBmZXRjaGluZyBzb25ncycpXG4gICAgICBzZXRTb25ncyhbXSlcbiAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKVxuICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6UgRmV0Y2hpbmcgYWxsIHNvbmdzIGZyb20gc3VwYWJhc2UgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgIGNvbnN0IHsgZGF0YTogc29uZ3NEYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcigndmlld3MnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3M6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygn4pyFIEZldGNoZWQgc29uZ3M6Jywgc29uZ3NEYXRhPy5sZW5ndGgpO1xuXG4gICAgICAvLyBGZXRjaCBsaWtlZCBzb25nc1xuICAgICAgY29uc29sZS5sb2coJ/Cfk6UgRmV0Y2hpbmcgbGlrZWQgc29uZ3MgZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhLCBlcnJvcjogbGlrZWRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIFxuICAgICAgaWYgKGxpa2VkRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIGxpa2VkIHNvbmdzOicsIGxpa2VkRXJyb3IpXG4gICAgICB9IGVsc2UgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICB1c2VyTGlrZWRTb25ncyA9IG5ldyBTZXQobGlrZWREYXRhLm1hcChpdGVtID0+IGl0ZW0uc29uZ19pZCkpXG4gICAgICAgIHNldExpa2VkU29uZ3ModXNlckxpa2VkU29uZ3MpXG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgRmV0Y2hlZCBsaWtlZCBzb25nczonLCB1c2VyTGlrZWRTb25ncy5zaXplKVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB1c2VyIGhpc3RvcnkgKGZvciBtaW51dGVzX2xpc3RlbmVkKVxuICAgICAgY29uc29sZS5sb2coJ/Cfk6UgRmV0Y2hpbmcgdXNlciBoaXN0b3J5IGZvciB1c2VyOicsIHVzZXJJZClcbiAgICAgIGNvbnN0IHsgZGF0YTogaGlzdG9yeURhdGEsIGVycm9yOiBoaXN0b3J5RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdoaXN0b3J5JylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCwgbWludXRlc19saXN0ZW5lZCwgc29uZ3MoKiknKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5vcmRlcignbWludXRlc19saXN0ZW5lZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgXG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBoaXN0b3J5OicsIGhpc3RvcnlFcnJvcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgRmV0Y2hlZCB1c2VyIGhpc3Rvcnk6JywgaGlzdG9yeURhdGE/Lmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0b3AgMTUgbW9zdCBsaXN0ZW5lZCBzb25ncyBmcm9tIGhpc3RvcnlcbiAgICAgIGNvbnN0IHRvcEhpc3RvcnkgPSAoaGlzdG9yeURhdGEgfHwgW10pLnNsaWNlKDAsIDE1KS5maWx0ZXIoaCA9PiBoLnNvbmdzKVxuICAgICAgLy8gQ29sbGVjdCB0YWdzIGFuZCBhcnRpc3RzIGZyb20gdG9wIDE1XG4gICAgICBjb25zdCB0YWdDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG4gICAgICBjb25zdCBhcnRpc3RDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG4gICAgICB0b3BIaXN0b3J5LmZvckVhY2goaCA9PiB7XG4gICAgICAgIC8vIGguc29uZ3MgbWF5IGJlIGFuIGFycmF5IG9yIG9iamVjdCwgdXNlIGZpcnN0IGlmIGFycmF5XG4gICAgICAgIGNvbnN0IHNvbmdPYmogPSBBcnJheS5pc0FycmF5KGguc29uZ3MpID8gaC5zb25nc1swXSA6IGguc29uZ3M7XG4gICAgICAgIChzb25nT2JqPy50YWdzIHx8IFtdKS5mb3JFYWNoKCh0YWc6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB0YWdDb3VudFt0XSA9ICh0YWdDb3VudFt0XSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc29uZ09iaj8uYXJ0aXN0KSB7XG4gICAgICAgICAgY29uc3QgYSA9IHNvbmdPYmouYXJ0aXN0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYXJ0aXN0Q291bnRbYV0gPSAoYXJ0aXN0Q291bnRbYV0gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEZpbmQgbW9zdCBjb21tb24gdGFncyBhbmQgYXJ0aXN0c1xuICAgICAgY29uc3QgY29tbW9uVGFncyA9IE9iamVjdC5lbnRyaWVzKHRhZ0NvdW50KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5zbGljZSgwLCA1KVxuICAgICAgICAubWFwKChbdGFnXSkgPT4gdGFnKTtcbiAgICAgIGNvbnN0IGNvbW1vbkFydGlzdHMgPSBPYmplY3QuZW50cmllcyhhcnRpc3RDb3VudClcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuICAgICAgICAuc2xpY2UoMCwgNSlcbiAgICAgICAgLm1hcCgoW2FydGlzdF0pID0+IGFydGlzdCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+Pt++4jyBGb3VuZCBzaW1pbGFyIHRhZ3M6JywgY29tbW9uVGFncyk7XG4gICAgICBjb25zb2xlLmxvZygn8J+OpCBGb3VuZCBzaW1pbGFyIGFydGlzdHM6JywgY29tbW9uQXJ0aXN0cyk7XG5cbiAgICAgIC8vIFNvbmdzIGluIGhpc3RvcnkgKHRvIGV4Y2x1ZGUgZm9yIHNtYXJ0IHNvcnQpXG4gICAgICBjb25zdCBoaXN0b3J5U29uZ0lkcyA9IG5ldyBTZXQoKGhpc3RvcnlEYXRhIHx8IFtdKS5tYXAoaCA9PiBoLnNvbmdfaWQ/LnRvU3RyaW5nKCkpKTtcblxuICAgICAgLy8gQ29udmVydCBhbGwgc29uZ3NcbiAgICAgIGNvbnN0IGNvbnZlcnRlZFNvbmdzID0gc29uZ3NEYXRhPy5tYXAoc29uZyA9PlxuICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmcsIHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKVxuICAgICAgKSB8fCBbXTtcblxuICAgICAgc2V0U29uZ3MoY29udmVydGVkU29uZ3MpOyAvLyBzb25ncyBpcyBub3cgYWxsIHNvbmdzLCBub3QgcGVyc29uYWxpemVkXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNldCBhbGwgc29uZ3M6JywgY29udmVydGVkU29uZ3MubGVuZ3RoKVxuXG4gICAgICAvLyBGaWx0ZXIgb3V0IHNvbmdzIGluIGhpc3RvcnkgZm9yIHBlcnNvbmFsaXplZCBzb3J0XG4gICAgICBjb25zdCBmaWx0ZXJlZFNvbmdzID0gY29udmVydGVkU29uZ3MuZmlsdGVyKHNvbmcgPT4gIWhpc3RvcnlTb25nSWRzLmhhcyhzb25nLmlkKSk7XG5cbiAgICAgIC8vIFNjb3JlIHNvbmdzIGJ5IHRhZy9hcnRpc3QgbWF0Y2hcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gZmlsdGVyZWRTb25ncy5tYXAoc29uZyA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIC8vIFRhZyBtYXRjaFxuICAgICAgICBjb25zdCBzb25nVGFncyA9IChzb25nLnRhZ3MgfHwgW10pLm1hcCgodDogc3RyaW5nKSA9PiB0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzY29yZSArPSBzb25nVGFncy5maWx0ZXIodCA9PiBjb21tb25UYWdzLmluY2x1ZGVzKHQpKS5sZW5ndGggKiAxMDtcbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoXG4gICAgICAgIGlmIChzb25nLmFydGlzdCAmJiBjb21tb25BcnRpc3RzLmluY2x1ZGVzKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhcml0eVxuICAgICAgICBzY29yZSArPSAoc29uZy52aWV3cyB8fCAwKSArIChzb25nLmxpa2VzIHx8IDApO1xuICAgICAgICByZXR1cm4geyBzb25nLCBzY29yZSB9O1xuICAgICAgfSk7XG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGRlc2NlbmRpbmdcbiAgICAgIGNvbnN0IHBlcnNvbmFsaXplZFNvcnRlZCA9IHNjb3JlZFNvbmdzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKS5tYXAocyA9PiBzLnNvbmcpO1xuXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhwZXJzb25hbGl6ZWRTb3J0ZWQpO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBTZXQgcGVyc29uYWxpemVkIHNvbmdzOicsIHBlcnNvbmFsaXplZFNvcnRlZC5sZW5ndGgpXG5cbiAgICAgIC8vIFRyZW5kaW5nOiB0b3AgMTUgYnkgdmlld3MrbGlrZXMgKGZyb20gYWxsIHNvbmdzLCBpbmNsdWRpbmcgaGlzdG9yeSlcbiAgICAgIGNvbnN0IHRyZW5kaW5nID0gWy4uLmNvbnZlcnRlZFNvbmdzXVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gKGIudmlld3MgKyBiLmxpa2VzKSAtIChhLnZpZXdzICsgYS5saWtlcykpXG4gICAgICAgIC5zbGljZSgwLCAxNSk7XG4gICAgICBzZXRUcmVuZGluZ1NvbmdzKHRyZW5kaW5nKTtcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU2V0IHRyZW5kaW5nIHNvbmdzOicsIHRyZW5kaW5nLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmxvZygn8J+UpSBUcmVuZGluZyBzb25nczonLCB0cmVuZGluZy5zbGljZSgwLCA1KS5tYXAocyA9PiBgJHtzLm5hbWV9ICgke3Mudmlld3N9IHZpZXdzLCAke3MubGlrZXN9IGxpa2VzKWApKTtcblxuICAgICAgLy8gU2V0IGxhc3QgcGxheWVkIHNvbmdcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OlIEZldGNoaW5nIGxhc3QgcGxheWVkIHNvbmcgZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlcklkKVxuICAgICAgICAuc2luZ2xlKCk7XG4gICAgICBcbiAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHVzZXIgZGF0YTonLCB1c2VyRXJyb3IpXG4gICAgICB9IGVsc2UgaWYgKHVzZXJEYXRhPy5sYXN0X3NvbmdfZmlsZV9pZCkge1xuICAgICAgICBjb25zdCBsYXN0U29uZyA9IGNvbnZlcnRlZFNvbmdzLmZpbmQoc29uZyA9PiBzb25nLmZpbGVfaWQgPT09IHVzZXJEYXRhLmxhc3Rfc29uZ19maWxlX2lkKVxuICAgICAgICBpZiAobGFzdFNvbmcpIHtcbiAgICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhsYXN0U29uZylcbiAgICAgICAgICBjb25zb2xlLmxvZygn4pyFIFNldCBsYXN0IHBsYXllZCBzb25nOicsIGxhc3RTb25nLm5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhbXSlcbiAgICAgIHNldFRyZW5kaW5nU29uZ3MoW10pXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZyBhbmQgZmlsdGVyaW5nXG4gIGNvbnN0IGdldFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBjdXJyZW50U29uZzogU29uZywgbGlzdGVuZWRTb25ncz86IFNldDxzdHJpbmc+KTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgRmV0Y2hpbmcgcGVyc29uYWxpemVkIHNvbmdzIGZvcjonLCBjdXJyZW50U29uZy5uYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IExpc3RlbmVkIHNvbmdzIGNvdW50OicsIGxpc3RlbmVkU29uZ3M/LnNpemUgfHwgMCk7XG4gICAgICBcbiAgICAgIC8vIDEuIEZldGNoIGFsbCBzb25ncyBmcm9tIGNhY2hlIG9yIGNsb3VkXG4gICAgICBsZXQgc29uZ3NEYXRhID0gc29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCFzb25nc0RhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6UgQ2FjaGUgbWlzcywgZmV0Y2hpbmcgc29uZ3MgZnJvbSBkYXRhYmFzZS4uLicpXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgICAuc2VsZWN0KCcqJyk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBzb25ncyBmb3IgcGVyc29uYWxpemF0aW9uOicsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gc29uZ3MgZm91bmQgaW4gZGF0YWJhc2UnKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgc29uZ3NEYXRhID0gZGF0YTtcbiAgICAgICAgc29uZ3NDYWNoZS5jdXJyZW50ID0gZGF0YTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBTb25ncyBjYWNoZWQ6JywgZGF0YS5sZW5ndGgpXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEZldGNoIHVzZXIncyBsaXN0ZW5pbmcgaGlzdG9yeSAobm90IGNhY2hlZCwgYXMgaXQgbWF5IGNoYW5nZSBmcmVxdWVudGx5KVxuICAgICAgY29uc29sZS5sb2coJ/Cfk6UgRmV0Y2hpbmcgbGlzdGVuaW5nIGhpc3RvcnkgZm9yIHBlcnNvbmFsaXphdGlvbi4uLicpXG4gICAgICBjb25zdCB7IGRhdGE6IGhpc3RvcnlEYXRhLCBlcnJvcjogaGlzdG9yeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQsIG1pbnV0ZXNfbGlzdGVuZWQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpO1xuICAgICAgaWYgKGhpc3RvcnlFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgaGlzdG9yeTonLCBoaXN0b3J5RXJyb3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlzdG9yeU1hcCA9IG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCk7XG4gICAgICBpZiAoaGlzdG9yeURhdGEpIHtcbiAgICAgICAgaGlzdG9yeURhdGEuZm9yRWFjaChoID0+IGhpc3RvcnlNYXAuc2V0KGguc29uZ19pZCwgaC5taW51dGVzX2xpc3RlbmVkIHx8IDApKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBIaXN0b3J5IGxvYWRlZDonLCBoaXN0b3J5RGF0YS5sZW5ndGgsICdlbnRyaWVzJylcbiAgICAgIH1cblxuICAgICAgLy8gMy4gR2V0IHVzZXIncyBsaWtlZCBzb25ncyBmcm9tIGNhY2hlIG9yIGNsb3VkXG4gICAgICBsZXQgdXNlckxpa2VkU29uZ3MgPSBsaWtlZFNvbmdzQ2FjaGUuY3VycmVudDtcbiAgICAgIGlmICghdXNlckxpa2VkU29uZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk6UgQ2FjaGUgbWlzcywgZmV0Y2hpbmcgbGlrZWQgc29uZ3MuLi4nKVxuICAgICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzIS5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSB1c2VyTGlrZWRTb25ncztcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBMaWtlZCBzb25ncyBjYWNoZWQ6JywgdXNlckxpa2VkU29uZ3Muc2l6ZSlcbiAgICAgIH1cblxuICAgICAgLy8gNC4gRmlsdGVyIGFuZCBzY29yZSBzb25ncyAoYWRkIGxhbmd1YWdlIGZpbHRlcilcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsdGVyID0gY3VycmVudFNvbmcubGFuZ3VhZ2U7XG4gICAgICBjb25zdCBhdmFpbGFibGVTb25ncyA9IHNvbmdzRGF0YS5maWx0ZXIoKHNvbmcpID0+IHtcbiAgICAgICAgLy8gRXhjbHVkZSBjdXJyZW50IHNvbmdcbiAgICAgICAgaWYgKHNvbmcuZmlsZV9pZCA9PT0gY3VycmVudFNvbmcuZmlsZV9pZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGNsdWRlIGxpc3RlbmVkIHNvbmdzIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChsaXN0ZW5lZFNvbmdzICYmIGxpc3RlbmVkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4Y2x1ZGluZyBsaXN0ZW5lZCBzb25nOiAke3NvbmcubmFtZX0gYnkgJHtzb25nLmFydGlzdH1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBpbmNsdWRlIHNvbmdzIHdpdGggdGhlIHNhbWUgbGFuZ3VhZ2UgYXMgY3VycmVudCBzb25nXG4gICAgICAgIGlmIChzb25nLmxhbmd1YWdlICE9PSBsYW5ndWFnZUZpbHRlcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+OtSBBdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nIChsYW5ndWFnZTogJHtsYW5ndWFnZUZpbHRlcn0pOiAke2F2YWlsYWJsZVNvbmdzLmxlbmd0aH1gKTtcblxuICAgICAgaWYgKGF2YWlsYWJsZVNvbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBObyBhdmFpbGFibGUgc29uZ3MgYWZ0ZXIgZmlsdGVyaW5nJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gNS4gU2NvcmUgYW5kIHNvcnQgc29uZ3NcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gYXZhaWxhYmxlU29uZ3MubWFwKChzb25nKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgICAgLy8gVGFnIG1hdGNoaW5nIChoaWdoZXN0IHByaW9yaXR5KVxuICAgICAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBzb25nLnRhZ3M/LmZpbHRlcigodGFnOiBzdHJpbmcpID0+XG4gICAgICAgICAgY3VycmVudFNvbmcudGFncz8uaW5jbHVkZXModGFnKVxuICAgICAgICApIHx8IFtdO1xuICAgICAgICBzY29yZSArPSBtYXRjaGluZ1RhZ3MubGVuZ3RoICogMTU7XG5cbiAgICAgICAgLy8gQXJ0aXN0IG1hdGNoaW5nXG4gICAgICAgIGlmIChzb25nLmFydGlzdCA9PT0gY3VycmVudFNvbmcuYXJ0aXN0KSB7XG4gICAgICAgICAgc2NvcmUgKz0gMjU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYW5ndWFnZSBtYXRjaGluZ1xuICAgICAgICBpZiAoc29uZy5sYW5ndWFnZSA9PT0gY3VycmVudFNvbmcubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExpc3RlbmluZyBoaXN0b3J5IGJvb3N0XG4gICAgICAgIGNvbnN0IGxpc3RlbmVkTWludXRlcyA9IGhpc3RvcnlNYXAuZ2V0KHNvbmcuZmlsZV9pZCkgfHwgMDtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5taW4obGlzdGVuZWRNaW51dGVzICogMiwgMjApOyAvLyBDYXAgYXQgMjAgcG9pbnRzXG5cbiAgICAgICAgLy8gUG9wdWxhcml0eSBib29zdCAobGlrZXMgYW5kIHZpZXdzKVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcubGlrZXMgfHwgMCkpICogMjtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLnZpZXdzIHx8IDApKSAqIDE7XG5cbiAgICAgICAgLy8gTGlrZWQgc29uZ3MgYm9vc3RcbiAgICAgICAgaWYgKHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjb250cm9sbGVkIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmVwZXRpdGlvblxuICAgICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogMztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLFxuICAgICAgICAgIHNjb3JlXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gNi4gU29ydCBieSBzY29yZSBhbmQgcmV0dXJuIHRvcCByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IHNjb3JlZFNvbmdzXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcbiAgICAgICAgLnNsaWNlKDAsIDEwKSAvLyBHZXQgbW9yZSBzb25ncyB0byBoYXZlIGEgYnVmZmVyXG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFBlcnNvbmFsaXplZCByZWNvbW1lbmRhdGlvbnM6JywgcmVjb21tZW5kYXRpb25zLnNsaWNlKDAsIDUpLm1hcChzID0+IGAke3MubmFtZX0gYnkgJHtzLmFydGlzdH1gKSk7XG4gICAgICBjb25zb2xlLmxvZygn8J+OtSBUb3RhbCBhdmFpbGFibGUgc29uZ3M6JywgYXZhaWxhYmxlU29uZ3MubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW4gZ2V0UGVyc29uYWxpemVkU29uZ3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBGZXRjaCByZWNlbnRseSBwbGF5ZWQgc29uZ3MgYmFzZWQgb24gbGlzdGVuaW5nIGhpc3RvcnlcbiAgY29uc3QgZmV0Y2hSZWNlbnRseVBsYXllZCA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlIGZvciBmZXRjaGluZyByZWNlbnRseSBwbGF5ZWQnKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TpSBGZXRjaGluZyByZWNlbnRseSBwbGF5ZWQgc29uZ3MgZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgLy8gR2V0IHVzZXIncyBsaXN0ZW5pbmcgaGlzdG9yeSBzb3J0ZWQgYnkgbWludXRlcyBsaXN0ZW5lZFxuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSwgZXJyb3I6IGhpc3RvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBzb25nX2lkLFxuICAgICAgICAgIG1pbnV0ZXNfbGlzdGVuZWQsXG4gICAgICAgICAgc29uZ3MgKCopXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLm9yZGVyKCdtaW51dGVzX2xpc3RlbmVkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdCg5KVxuXG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyByZWNlbnRseSBwbGF5ZWQ6JywgaGlzdG9yeUVycm9yKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFoaXN0b3J5RGF0YSB8fCBoaXN0b3J5RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk60gTm8gcmVjZW50bHkgcGxheWVkIHNvbmdzIGZvdW5kJylcbiAgICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1c2VyJ3MgbGlrZWQgc29uZ3MgZm9yIHByb3BlciBjb252ZXJzaW9uXG4gICAgICBjb25zb2xlLmxvZygn8J+TpSBGZXRjaGluZyBsaWtlZCBzb25ncyBmb3IgcmVjZW50bHkgcGxheWVkIGNvbnZlcnNpb24uLi4nKVxuICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgbGlrZWREYXRhLmZvckVhY2goaXRlbSA9PiB1c2VyTGlrZWRTb25ncy5hZGQoaXRlbS5zb25nX2lkKSlcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCB0byBTb25nIGZvcm1hdFxuICAgICAgY29uc3QgcmVjZW50U29uZ3MgPSBoaXN0b3J5RGF0YVxuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zb25ncykgLy8gRW5zdXJlIHNvbmcgZGF0YSBleGlzdHNcbiAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBzb25nT2JqID0gQXJyYXkuaXNBcnJheShpdGVtLnNvbmdzKSA/IGl0ZW0uc29uZ3NbMF0gOiBpdGVtLnNvbmdzO1xuICAgICAgICAgIHJldHVybiBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmdPYmosIHVzZXJMaWtlZFNvbmdzLmhhcyhpdGVtLnNvbmdfaWQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHNldFJlY2VudGx5UGxheWVkU29uZ3MocmVjZW50U29uZ3MpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNldCByZWNlbnRseSBwbGF5ZWQgc29uZ3M6JywgcmVjZW50U29uZ3MubGVuZ3RoKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgcmVjZW50bHkgcGxheWVkIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyIHBsYXlsaXN0c1xuICBjb25zdCBmZXRjaFBsYXlsaXN0cyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlIGZvciBmZXRjaGluZyBwbGF5bGlzdHMnKVxuICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OlIEZldGNoaW5nIHBsYXlsaXN0cyBmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICBjb25zdCB7IGRhdGE6IHBsYXlsaXN0c0RhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwbGF5bGlzdF9zb25ncyAoXG4gICAgICAgICAgICBzb25ncyAoKilcbiAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFBsYXlsaXN0czogUGxheWxpc3RbXSA9IHBsYXlsaXN0c0RhdGE/Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgIGNvbnN0IHBsYXlsaXN0U29uZ3MgPSBwbGF5bGlzdC5wbGF5bGlzdF9zb25ncz8ubWFwKChwczogYW55KSA9PiBcbiAgICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHBzLnNvbmdzLCBsaWtlZFNvbmdzLmhhcyhwcy5zb25ncy5maWxlX2lkKSlcbiAgICAgICAgKSB8fCBbXVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHBsYXlsaXN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgbmFtZTogcGxheWxpc3QubmFtZSxcbiAgICAgICAgICBzb25nQ291bnQ6IHBsYXlsaXN0U29uZ3MubGVuZ3RoLFxuICAgICAgICAgIGltYWdlOiBwbGF5bGlzdFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdFNvbmdzXG4gICAgICAgIH1cbiAgICAgIH0pIHx8IFtdXG5cbiAgICAgIHNldFBsYXlsaXN0cyhjb252ZXJ0ZWRQbGF5bGlzdHMpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNldCBwbGF5bGlzdHM6JywgY29udmVydGVkUGxheWxpc3RzLmxlbmd0aClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIHBsYXlsaXN0czonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBUb2dnbGUgbGlrZSBzb25nXG4gIGNvbnN0IHRvZ2dsZUxpa2UgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlIGZvciB0b2dnbGluZyBsaWtlJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpO1xuICAgIGNvbnN0IGlzQ3VycmVudGx5TGlrZWQgPSBsaWtlZFNvbmdzLmhhcyhzb25nRmlsZUlkKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgJHtpc0N1cnJlbnRseUxpa2VkID8gJ/CfkpQnIDogJ+KdpO+4jyd9IFRvZ2dsaW5nIGxpa2UgZm9yIHNvbmc6YCwgc29uZ0lkLCAnVXNlcjonLCB1c2VySWQpXG4gICAgICBcbiAgICAgIGlmIChpc0N1cnJlbnRseUxpa2VkKSB7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIGxpa2VkX3NvbmdzXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgICAgLmVxKCdzb25nX2lkJywgc29uZ0ZpbGVJZCk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlbW92aW5nIGxpa2U6JywgZXJyb3IpXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY3JlbWVudCBsaWtlc1xuICAgICAgICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2RlY3JlbWVudF9zb25nX2xpa2VzJywgeyBzb25nX2ZpbGVfaWQ6IHNvbmdGaWxlSWQgfSk7XG5cbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0KHByZXYpO1xuICAgICAgICAgIG5ld1NldC5kZWxldGUoc29uZ0ZpbGVJZCk7XG4gICAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgU29uZyB1bmxpa2VkIHN1Y2Nlc3NmdWxseScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgdG8gbGlrZWRfc29uZ3NcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgICAgc29uZ19pZDogc29uZ0ZpbGVJZCxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWRkaW5nIGxpa2U6JywgZXJyb3IpXG4gICAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluY3JlbWVudCBsaWtlc1xuICAgICAgICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2luY3JlbWVudF9zb25nX2xpa2VzJywgeyBzb25nX2ZpbGVfaWQ6IHNvbmdGaWxlSWQgfSk7XG5cbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IG5ldyBTZXQocHJldikuYWRkKHNvbmdGaWxlSWQpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBTb25nIGxpa2VkIHN1Y2Nlc3NmdWxseScpXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzb25ncyBzdGF0ZVxuICAgICAgc2V0U29uZ3MocHJldlNvbmdzID0+XG4gICAgICAgIHByZXZTb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4uc29uZyxcbiAgICAgICAgICAgICAgICBpc0xpa2VkOiAhaXNDdXJyZW50bHlMaWtlZCxcbiAgICAgICAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBzb25nXG4gICAgICAgIClcbiAgICAgICk7XG5cbiAgICAgIC8vIFVwZGF0ZSBwbGF5bGlzdHMgc3RhdGVcbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2UGxheWxpc3RzID0+XG4gICAgICAgIHByZXZQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+ICh7XG4gICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgc29uZ3M6IHBsYXlsaXN0LnNvbmdzLm1hcChzb25nID0+XG4gICAgICAgICAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAuLi5zb25nLFxuICAgICAgICAgICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogc29uZ1xuICAgICAgICAgICksXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHRvZ2dsaW5nIGxpa2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDcmVhdGUgcGxheWxpc3RcbiAgY29uc3QgY3JlYXRlUGxheWxpc3QgPSBhc3luYyAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB1c2VyIElEIGF2YWlsYWJsZSBmb3IgY3JlYXRpbmcgcGxheWxpc3QnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OdIENyZWF0aW5nIHBsYXlsaXN0OicsIG5hbWUsICdmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQbGF5bGlzdDogUGxheWxpc3QgPSB7XG4gICAgICAgIGlkOiBkYXRhLmlkLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgc29uZ0NvdW50OiAwLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgc29uZ3M6IFtdXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdQbGF5bGlzdF0pXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBsYXlsaXN0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5OicsIG5ld1BsYXlsaXN0Lm5hbWUpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBjcmVhdGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBEZWxldGUgcGxheWxpc3RcbiAgY29uc3QgZGVsZXRlUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB1c2VyIElEIGF2YWlsYWJsZSBmb3IgZGVsZXRpbmcgcGxheWxpc3QnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn5eR77iPIERlbGV0aW5nIHBsYXlsaXN0OicsIHBsYXlsaXN0SWQsICdmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBwcmV2LmZpbHRlcihwbGF5bGlzdCA9PiBwbGF5bGlzdC5pZCAhPT0gcGxheWxpc3RJZCkpXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBsYXlsaXN0IGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmFtZSBwbGF5bGlzdFxuICBjb25zdCByZW5hbWVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gdXNlciBJRCBhdmFpbGFibGUgZm9yIHJlbmFtaW5nIHBsYXlsaXN0JylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn4pyP77iPIFJlbmFtaW5nIHBsYXlsaXN0OicsIHBsYXlsaXN0SWQsICd0bzonLCBuZXdOYW1lLCAnZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC51cGRhdGUoeyBuYW1lOiBuZXdOYW1lIH0pXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlbmFtaW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4gXG4gICAgICAgICAgcGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQgXG4gICAgICAgICAgICA/IHsgLi4ucGxheWxpc3QsIG5hbWU6IG5ld05hbWUgfVxuICAgICAgICAgICAgOiBwbGF5bGlzdFxuICAgICAgICApXG4gICAgICApXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFBsYXlsaXN0IHJlbmFtZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlbmFtaW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBzb25nIHRvIHBsYXlsaXN0XG4gIGNvbnN0IGFkZFNvbmdUb1BsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZzogU29uZykgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gdXNlciBJRCBhdmFpbGFibGUgZm9yIGFkZGluZyBzb25nIHRvIHBsYXlsaXN0JylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn4p6VIEFkZGluZyBzb25nOicsIHNvbmcubmFtZSwgJ3RvIHBsYXlsaXN0OicsIHBsYXlsaXN0SWQsICdmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwbGF5bGlzdF9pZDogcGFyc2VJbnQocGxheWxpc3RJZCksXG4gICAgICAgICAgc29uZ19pZDogc29uZy5maWxlX2lkXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgYWRkaW5nIHNvbmcgdG8gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCBzb25nRXhpc3RzID0gcGxheWxpc3Quc29uZ3Muc29tZShzID0+IHMuaWQgPT09IHNvbmcuaWQpXG4gICAgICAgICAgICBpZiAoIXNvbmdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gWy4uLnBsYXlsaXN0LnNvbmdzLCBzb25nXVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8IHBsYXlsaXN0LmltYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBjb25zb2xlLmxvZygn4pyFIFNvbmcgYWRkZWQgdG8gcGxheWxpc3Qgc3VjY2Vzc2Z1bGx5JylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGFkZGluZyBzb25nIHRvIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBzb25nIGZyb20gcGxheWxpc3RcbiAgY29uc3QgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB1c2VyIElEIGF2YWlsYWJsZSBmb3IgcmVtb3Zpbmcgc29uZyBmcm9tIHBsYXlsaXN0JylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn4p6WIFJlbW92aW5nIHNvbmc6Jywgc29uZ0lkLCAnZnJvbSBwbGF5bGlzdDonLCBwbGF5bGlzdElkLCAnZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgncGxheWxpc3RfaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCdzb25nX2lkJywgcGFyc2VJbnQoc29uZ0lkKSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZW1vdmluZyBzb25nIGZyb20gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBwbGF5bGlzdC5zb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlkICE9PSBzb25nSWQpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgY29uc29sZS5sb2coJ+KchSBTb25nIHJlbW92ZWQgZnJvbSBwbGF5bGlzdCBzdWNjZXNzZnVsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcmVtb3Zpbmcgc29uZyBmcm9tIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gIGNvbnN0IHVwZGF0ZUxhc3RTb25nID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gZ2V0VXNlcklkKClcbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ+KdjCBObyB1c2VyIElEIGF2YWlsYWJsZSBmb3IgdXBkYXRpbmcgbGFzdCBzb25nJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+TnSBVcGRhdGluZyBsYXN0IHNvbmc6Jywgc29uZ0lkLCAnZm9yIHVzZXI6JywgdXNlcklkKVxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnVwZGF0ZSh7IGxhc3Rfc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VySWQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgdXBkYXRpbmcgbGFzdCBzb25nOicsIGVycm9yKVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ+KchSBMYXN0IHNvbmcgdXBkYXRlZCBzdWNjZXNzZnVsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgdXBkYXRpbmcgbGFzdCBzb25nOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCBsaXN0ZW5pbmcgaGlzdG9yeSB3aXRoIHByb3BlciB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHJlY29yZExpc3RlbmluZ0hpc3RvcnkgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSBnZXRVc2VySWQoKVxuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlIGZvciByZWNvcmRpbmcgbGlzdGVuaW5nIGhpc3RvcnknKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHNvbmcgcGxheWluZywgcmVjb3JkIGl0cyBsaXN0ZW5pbmcgdGltZVxuICAgIGlmIChjdXJyZW50U29uZ1JlZi5jdXJyZW50ICYmIGN1cnJlbnRTb25nU3RhcnRUaW1lKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IG1pbnV0ZXNMaXN0ZW5lZCA9IChlbmRUaW1lLmdldFRpbWUoKSAtIGN1cnJlbnRTb25nU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKTtcblxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4ogUmVjb3JkaW5nIGxpc3RlbmluZyB0aW1lOicsIG1pbnV0ZXMsICdtaW51dGVzIGZvciBzb25nOicsIGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VySWQsXG4gICAgICAgICAgICBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpLFxuICAgICAgICAgICAgbWludXRlczogbWludXRlcyxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlY29yZGluZyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEhpc3RvcnkgdXBkYXRlZDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgcHJldmlvdXMgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBuZXcgc29uZyBhcyBjdXJyZW50XG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IHNvbmdJZFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG5ldyBEYXRlKCkpXG4gICAgY29uc29sZS5sb2coJ/CfjrUgU3RhcnRlZCB0cmFja2luZyBzb25nOicsIHNvbmdJZClcbiAgICBcbiAgICAvLyBVcGRhdGUgbGFzdCBzb25nIGluIHVzZXIgcHJvZmlsZVxuICAgIGF3YWl0IHVwZGF0ZUxhc3RTb25nKHNvbmdJZClcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+Rge+4jyBJbmNyZW1lbnRpbmcgdmlld3MgZm9yIHNvbmc6Jywgc29uZ0lkKVxuICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ192aWV3cycsIHsgc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pO1xuICAgICAgY29uc29sZS5sb2coJ+KchSBWaWV3cyBpbmNyZW1lbnRlZCBzdWNjZXNzZnVsbHknKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgaW5jcmVtZW50aW5nIHNvbmcgdmlld3M6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0b3AgY3VycmVudCBzb25nIHRyYWNraW5nICh3aGVuIHBsYXllciBpcyBjbG9zZWQpXG4gIGNvbnN0IHN0b3BDdXJyZW50U29uZ1RyYWNraW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUgJiYgdXNlcklkKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApXG4gICAgICBcbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5uRIFJlY29yZGluZyBmaW5hbCBsaXN0ZW5pbmcgdGltZTonLCBtaW51dGVzLCAnbWludXRlcyBmb3Igc29uZzonLCBjdXJyZW50U29uZ1JlZi5jdXJyZW50KVxuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgICAgICAgIHVzZXJfdXVpZDogdXNlcklkLFxuICAgICAgICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5IG9uIHN0b3A6JywgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+bkSBIaXN0b3J5IHVwZGF0ZWQgb24gc3RvcDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgZmluYWwgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgPSBudWxsXG4gICAgc2V0Q3VycmVudFNvbmdTdGFydFRpbWUobnVsbClcbiAgICBjb25zb2xlLmxvZygn8J+bkSBTdG9wcGVkIHNvbmcgdHJhY2tpbmcnKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGdldFVzZXJJZCgpXG4gICAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4p2MIE5vIHVzZXIgSUQgYXZhaWxhYmxlLCByZXNldHRpbmcgZGF0YScpXG4gICAgICAgIC8vIFJlc2V0IGRhdGEgd2hlbiBubyB1c2VyXG4gICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IG51bGxcbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICAgIHNldFNvbmdzKFtdKVxuICAgICAgICBzZXRQZXJzb25hbGl6ZWRTb25ncyhbXSlcbiAgICAgICAgc2V0VHJlbmRpbmdTb25ncyhbXSlcbiAgICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgICBzZXRMaWtlZFNvbmdzKG5ldyBTZXQoKSlcbiAgICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobnVsbClcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIExvYWRpbmcgZGF0YSBmb3IgdXNlcjonLCB1c2VySWQpXG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW2ZldGNoU29uZ3MoKSwgZmV0Y2hQbGF5bGlzdHMoKSwgZmV0Y2hSZWNlbnRseVBsYXllZCgpXSlcbiAgICAgICAgY29uc29sZS5sb2coJ+KchSBBbGwgZGF0YSBsb2FkZWQgc3VjY2Vzc2Z1bGx5JylcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpXG4gICAgICAgIC8vIFJlc2V0IGRhdGEgb24gZXJyb3JcbiAgICAgICAgc2V0U29uZ3MoW10pXG4gICAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKVxuICAgICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkRGF0YSgpXG4gIH0sIFt1c2VyXSkgLy8gS2VlcCBkZXBlbmRlbmN5IG9uIHVzZXIgdG8gdHJpZ2dlciB3aGVuIGF1dGggc3RhdGUgY2hhbmdlc1xuXG4gIHJldHVybiB7XG4gICAgc29uZ3MsIC8vIGFsbCBzb25nc1xuICAgIHBlcnNvbmFsaXplZFNvbmdzLCAvLyBzbWFydCBzb3J0ZWQsIGZpbHRlcmVkLCBhbmQgaGlzdG9yeS1leGNsdWRlZCBsaXN0XG4gICAgdHJlbmRpbmdTb25ncywgLy8gdG9wIDE1IHRyZW5kaW5nIGJ5IHZpZXdzK2xpa2VzXG4gICAgcGxheWxpc3RzLFxuICAgIGxpa2VkU29uZ3M6IHNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaXNMaWtlZCksXG4gICAgcmVjZW50bHlQbGF5ZWRTb25ncyxcbiAgICBsYXN0UGxheWVkU29uZyxcbiAgICBsb2FkaW5nLFxuICAgIHRvZ2dsZUxpa2UsXG4gICAgY3JlYXRlUGxheWxpc3QsXG4gICAgZGVsZXRlUGxheWxpc3QsXG4gICAgcmVuYW1lUGxheWxpc3QsXG4gICAgYWRkU29uZ1RvUGxheWxpc3QsXG4gICAgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCxcbiAgICByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5LFxuICAgIHN0b3BDdXJyZW50U29uZ1RyYWNraW5nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygn8J+UhCBSZWZyZXNoaW5nIGFsbCBkYXRhLi4uJylcbiAgICAgIGZldGNoU29uZ3MoKVxuICAgICAgZmV0Y2hQbGF5bGlzdHMoKVxuICAgICAgZmV0Y2hSZWNlbnRseVBsYXllZCgpXG4gICAgfSxcbiAgICBnZXRQZXJzb25hbGl6ZWRTb25ncyxcbiAgICBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzXG4gIH1cbn0iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZVN1cGFiYXNlRGF0YSIsInVzZXIiLCJzb25nc0NhY2hlIiwibGlrZWRTb25nc0NhY2hlIiwic29uZ3MiLCJzZXRTb25ncyIsInBlcnNvbmFsaXplZFNvbmdzIiwic2V0UGVyc29uYWxpemVkU29uZ3MiLCJ0cmVuZGluZ1NvbmdzIiwic2V0VHJlbmRpbmdTb25ncyIsInBsYXlsaXN0cyIsInNldFBsYXlsaXN0cyIsImxpa2VkU29uZ3MiLCJzZXRMaWtlZFNvbmdzIiwiU2V0IiwibGFzdFBsYXllZFNvbmciLCJzZXRMYXN0UGxheWVkU29uZyIsInJlY2VudGx5UGxheWVkU29uZ3MiLCJzZXRSZWNlbnRseVBsYXllZFNvbmdzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50U29uZ1N0YXJ0VGltZSIsInNldEN1cnJlbnRTb25nU3RhcnRUaW1lIiwiY3VycmVudFNvbmdSZWYiLCJnZXRVc2VySWQiLCJpZCIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyRGF0YSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWQiLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3MiLCJ1c2VySWQiLCJsaXN0ZW5lZFNvbmdzSW5CYXRjaCIsImV4Y2x1ZGVTb25ncyIsIm1hcCIsInMiLCJuYW1lIiwibGVuZ3RoIiwicHJlZmVycmVkVGFncyIsInByZWZlcnJlZEFydGlzdHMiLCJmb3JFYWNoIiwic29uZyIsInRhZ3MiLCJ0YWciLCJhZGQiLCJ0b0xvd2VyQ2FzZSIsImFydGlzdCIsIkFycmF5IiwiZnJvbSIsInNvbmdzRGF0YSIsImN1cnJlbnQiLCJkYXRhIiwic2VsZWN0Iiwid2FybiIsInVzZXJMaWtlZFNvbmdzIiwibGlrZWREYXRhIiwiZXEiLCJpdGVtIiwic29uZ19pZCIsInNpemUiLCJsYW5ndWFnZUZpbHRlciIsImxhbmd1YWdlIiwiYXZhaWxhYmxlU29uZ3MiLCJmaWx0ZXIiLCJoYXMiLCJmaWxlX2lkIiwidG9TdHJpbmciLCJzY29yZWRTb25ncyIsInNjb3JlIiwic29uZ1RhZ3MiLCJtYXRjaGluZ1RhZ3MiLCJsaXN0ZW5lZExhbmd1YWdlcyIsImluY2x1ZGVzIiwiTWF0aCIsImxpa2VzIiwidmlld3MiLCJyYW5kb20iLCJjb252ZXJ0RGF0YWJhc2VTb25nIiwicmVjb21tZW5kYXRpb25zIiwic29ydCIsImEiLCJiIiwic2xpY2UiLCJlbnRyeSIsImRiU29uZyIsImlzTGlrZWQiLCJpbWdfaWQiLCJpbWFnZSIsImZldGNoU29uZ3MiLCJvcmRlciIsImFzY2VuZGluZyIsImxpa2VkRXJyb3IiLCJoaXN0b3J5RGF0YSIsImhpc3RvcnlFcnJvciIsInRvcEhpc3RvcnkiLCJoIiwidGFnQ291bnQiLCJhcnRpc3RDb3VudCIsInNvbmdPYmoiLCJpc0FycmF5IiwidCIsImNvbW1vblRhZ3MiLCJPYmplY3QiLCJlbnRyaWVzIiwiY29tbW9uQXJ0aXN0cyIsImhpc3RvcnlTb25nSWRzIiwiY29udmVydGVkU29uZ3MiLCJmaWx0ZXJlZFNvbmdzIiwicGVyc29uYWxpemVkU29ydGVkIiwidHJlbmRpbmciLCJ1c2VyRXJyb3IiLCJzaW5nbGUiLCJsYXN0X3NvbmdfZmlsZV9pZCIsImxhc3RTb25nIiwiZmluZCIsImdldFBlcnNvbmFsaXplZFNvbmdzIiwiY3VycmVudFNvbmciLCJsaXN0ZW5lZFNvbmdzIiwiaGlzdG9yeU1hcCIsIk1hcCIsInNldCIsIm1pbnV0ZXNfbGlzdGVuZWQiLCJsaXN0ZW5lZE1pbnV0ZXMiLCJnZXQiLCJtaW4iLCJmZXRjaFJlY2VudGx5UGxheWVkIiwibGltaXQiLCJyZWNlbnRTb25ncyIsImZldGNoUGxheWxpc3RzIiwicGxheWxpc3RzRGF0YSIsImNvbnZlcnRlZFBsYXlsaXN0cyIsInBsYXlsaXN0IiwicGxheWxpc3RTb25ncyIsInBsYXlsaXN0X3NvbmdzIiwicHMiLCJzb25nQ291bnQiLCJ0b2dnbGVMaWtlIiwic29uZ0lkIiwic29uZ0ZpbGVJZCIsInBhcnNlSW50IiwiaXNDdXJyZW50bHlMaWtlZCIsImRlbGV0ZSIsInJwYyIsInNvbmdfZmlsZV9pZCIsInByZXYiLCJuZXdTZXQiLCJpbnNlcnQiLCJ1c2VyX2lkIiwicHJldlNvbmdzIiwicHJldlBsYXlsaXN0cyIsImNyZWF0ZVBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJkZWxldGVQbGF5bGlzdCIsInBsYXlsaXN0SWQiLCJyZW5hbWVQbGF5bGlzdCIsIm5ld05hbWUiLCJ1cGRhdGUiLCJhZGRTb25nVG9QbGF5bGlzdCIsInBsYXlsaXN0X2lkIiwic29uZ0V4aXN0cyIsInNvbWUiLCJ1cGRhdGVkU29uZ3MiLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwidXBkYXRlTGFzdFNvbmciLCJyZWNvcmRMaXN0ZW5pbmdIaXN0b3J5IiwiZW5kVGltZSIsIkRhdGUiLCJtaW51dGVzTGlzdGVuZWQiLCJnZXRUaW1lIiwibWludXRlcyIsInJvdW5kIiwidXNlcl91dWlkIiwic3RvcEN1cnJlbnRTb25nVHJhY2tpbmciLCJsb2FkRGF0YSIsIlByb21pc2UiLCJhbGwiLCJyZWZyZXNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});